"""
/***************************************************************************
 GIS
                                 A QGIS plugin
 This is an adaption of the SylvaRoad app for in qgis uses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np
from shapely.geometry import Point,LineString
from osgeo import gdal,ogr,osr
import os,datetime
from PyQt5.QtCore import QCoreApplication
from .functions import Distplan,build_Tab_neibs,diff_az


def conv_az_to_polar(az):
    
    """Converts azimuth angle to polar angle.

    Azimuth angle represents the angle measured clockwise from the north direction
    in the range [0, 360) degrees. Polar angle is measured counterclockwise from
    the positive x-axis in the range [0, 360) degrees.

    :param az: Azimuth angle in degrees.
    :type az: float

    :return: Polar angle corresponding to the given azimuth angle.
    :rtype: float

    :raises: None
    """
    return (360-(az-90))%360


def calculate_polar(x1,y1,x2,y2):
    
    """Calculates the azimuth between two points from their coordinates.

    :param x1: x-coordinate of the first point.
    :type x1: float
    :param y1: y-coordinate of the first point.
    :type y1: float
    :param x2: x-coordinate of the second point.
    :type x2: float
    :param y2: y-coordinate of the second point.
    :type y2: float

    :return: Azimuth angle between the two points in degrees.
    :rtype: float

    :raises: None
    """
    DX = x2-x1
    DY = y2-y1
    Deuc = np.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = np.degrees(np.arccos(DY/Deuc))
    Angle *=Fact
    az = Angle%360
    return conv_az_to_polar(az)


def build_radius(R):
    
    """Builds coordinates around a circle with radius R.

    :param R: Radius of the circle.
    :type R: float

    :return: Array of coordinates around the circle, where each row represents a point.
    :rtype: numpy.ndarray

    :raises: None
    """
    coords =np.zeros((360,3),dtype=np.float) 
    for pol in range(0,360):
        coords[pol,0]=pol
        coords[pol,1]= R*np.cos(np.radians((pol)%360))#x
        coords[pol,2]= R*np.sin(np.radians((pol)%360))#y
    return coords


def diff(az_to,az_from):   
    
    """Calculates the shortest difference between two azimuth angles.

    :param az_to: Destination azimuth angle.
    :type az_to: float
    :param az_from: Origin azimuth angle.
    :type az_from: float

    :return: Shortest difference between the two azimuth angles in degrees.
    :rtype: float

    :raises: None
    """
    if az_to>az_from:
        return min((360-(az_to-az_from),(az_to-az_from)))
    else:
        return min((360-(az_from-az_to),(az_from-az_to)))


def build_NeibTable(D_neighborhood,Csize,dtm,Obs,min_slope,max_slope):
    
    """ Description
    :type D_neighborhood:
    :param D_neighborhood:

    :type Csize:
    :param Csize:

    :type dtm:
    :param dtm:

    :type Obs:
    :param Obs:

    :type min_slope:
    :param min_slope:

    :type max_slope:
    :param max_slope:

    :raises:

    :rtype:
    """
    nbpix_neighborhood=int(D_neighborhood/Csize+0.5)
    x, y = np.meshgrid(np.arange(-nbpix_neighborhood, nbpix_neighborhood+1, dtype=int), 
                      np.arange(-nbpix_neighborhood, nbpix_neighborhood+1, dtype=int))
    coords = np.vstack((np.ndarray.flatten(x), np.ndarray.flatten(y))).T    
    coords = np.delete(coords, [nbpix_neighborhood*(2*nbpix_neighborhood+2)],axis=0)
    azimuts = np.copy(coords[:,0])*0.
    for i,neig in enumerate(coords):
        azimuts[i]=calculate_azimut(0,0,neig[1],-neig[0])
    dists_index = np.sqrt(np.sum(np.square(coords),axis=1))*Csize
    
    #keep only neibourg within distance
    tp = dists_index <= D_neighborhood
    coords=coords[tp]
    azimuts=np.float32(azimuts[tp])
    dists_index=np.float32(dists_index[tp])
    
    IdVois, Id, Tab_corresp,IdPix ,Slope =  build_Tab_neibs(Obs,dtm,azimuts,
                                                              dists_index,coords,
                                                              min_slope,max_slope,
                                                              np.sum(Obs==0))
    
    nbneibmax = np.max(Tab_corresp[:,2])
    
    return IdVois[:,:nbneibmax],Id[:,:nbneibmax],Tab_corresp,IdPix,Slope[:,:nbneibmax],dists_index,azimuts
    

def get_id_lacets(Path,angle_hairpin):
    
    """Identifies and categorizes loops (lacets) in a path based on azimuth angles.

    :param Path: Array containing path data.
    :type Path: numpy.ndarray
    :param angle_hairpin: Threshold angle for considering a loop as a hairpin.
    :type angle_hairpin: float

    :return: Array containing IDs and types of identified loops.
    :rtype: numpy.ndarray

    :raises: None
    """
    id_lacet_classique = []    
    for i,pt in enumerate(Path[1:-1]):
        az1 = pt[3]
        az2 = Path[i+2,3]
        difangle1 =  diff_az(az1,az2)
        if difangle1 > angle_hairpin:
            id_lacet_classique.append(i+1)   
            
    id_lacet_bis = [] 
    dif_angle = []
    for i,pt in enumerate(Path[1:-1]):
        if i in id_lacet_classique:
            continue
        if i-1 in id_lacet_classique:
            continue
        if i+1 in id_lacet_classique:
            continue
        if i+2 in id_lacet_classique:
            continue        
       
        if i+3<Path.shape[0]:
            az1 = pt[3]
            az2 = Path[i+2,3]
            difangle1 = diff_az(az1,az2)
            if abs((az2-difangle1)%360-az1)<0.1:
                difangle1*=-1
            az3 = Path[i+3,3]
            difangle2 =  diff_az(az2,az3)
            if abs((az3-difangle2)%360-az2)<0.1:
                difangle2*=-1          
            
            if i in id_lacet_bis:                
                idx = id_lacet_bis.index(i)
                if dif_angle[idx]> abs(difangle1+difangle2):
                    continue
                else:
                    del dif_angle[idx],id_lacet_bis[idx]
                
            if i-1 in id_lacet_bis:
                idx = id_lacet_bis.index(i-1)
                if dif_angle[idx]> abs(difangle1+difangle2):
                    continue
                else:
                    del dif_angle[idx],id_lacet_bis[idx]
                
            if abs(difangle1+difangle2) > angle_hairpin:
                dif_angle.append(abs(difangle1+difangle2))
                id_lacet_bis.append(i+1)
                      
    lacets = np.zeros((len(id_lacet_bis)+len(id_lacet_classique),2),dtype=np.int32)
    lacets[:len(id_lacet_bis),0]=id_lacet_bis
    lacets[:len(id_lacet_bis),1]=2
    lacets[len(id_lacet_bis):,0]=id_lacet_classique
    lacets[len(id_lacet_bis):,1]=1
    ind = np.lexsort([lacets[:,1],lacets[:,0]])
    
    return lacets[ind]


def trace_lace(Path,R,Extent,Csize,angle_hairpin,dtm,coefplat=2):   
    
    """Traces loops (lacets) along a path based on azimuth angles and surface characteristics.

    :param Path: Array containing path data.
    :type Path: numpy.ndarray

    :param R: Radius of the loop.
    :type R: float

    :param Extent: Extent of the area.
    :type Extent: tuple

    :param Csize: Cell size.
    :type Csize: float

    :param angle_hairpin: Threshold angle for considering a loop as a hairpin.
    :type angle_hairpin: float

    :param dtm: Digital Terrain Model (DTM) data.
    :type dtm: numpy.ndarray

    :param coefplat: Coefficient for adjusting the loop's surface characteristics, defaults to 2.
    :type coefplat: int, optional

    :return: Array containing traced path data with added loop details.
    :rtype: numpy.ndarray

    :raises: None
    """
    lacets = get_id_lacets(Path,angle_hairpin)
    
    coords = build_radius(R)
    x0,y0=get_xy0(Extent,Csize)
    newPath = np.zeros((Path.shape[0],Path.shape[1]+3))
    newPath[:,0:7] = Path[:,0:7]
    for i,pt in enumerate(Path):
        newPath[i,9]=dtm[int(pt[0]),int(pt[1])]   
      
    Path=np.copy(newPath)
    Path[:,0]=y0-Path[:,0]*Csize
    Path[:,1]=Path[:,1]*Csize+x0 
    for lac in lacets:
        Path[lac[0],7]=lac[0]
        Path[lac[0],8]=lac[1]
            
    for lac in lacets: 
        line_lac,method = lac 
        try:
            line_lac=np.argwhere(Path[:,7]==line_lac)[0,0]             
        except:
            continue

        if method==1:
            #Angle > hairpin between 2 segments / Center at turn
            B = Point(Path[line_lac,1], Path[line_lac,0])
        else:
            #Angle > hairpin between 3 segments 
            #Center on the middle point of the segment
            A = Point(Path[line_lac,1], Path[line_lac,0])
            D = Point(Path[line_lac+1,1], Path[line_lac+1,0])           
            B = Point(0.5*A.x+0.5*D.x,0.5*A.y+0.5*D.y)            
         
        RingR15 = B.buffer(R*coefplat).boundary
        #find intersection before
        #A = Point(Path[line_lac-1,1], Path[line_lac-1,0])  
        cutpt_bef = 0
        check_int=False
        while not check_int and cutpt_bef*Csize<R*(coefplat+0.5):   
            cutpt_bef+=1
            vois = []
            for ide in range(max(0,line_lac-cutpt_bef),line_lac+1):
                vois.append(Point(Path[ide,1], Path[ide,0]))
            RoadBef = LineString(vois)
            check_int = RingR15.intersects(RoadBef)
            
        if check_int:
            intbef = RingR15.intersection(RoadBef)
            x1 = Point(intbef.coords[0]) 
            x,y = Path[line_lac-cutpt_bef+1,1],Path[line_lac-cutpt_bef+1,0]
            D =  Distplan(y, x, x1.y, x1.x)
            x1z = Path[line_lac-cutpt_bef+1,9]-Path[line_lac-cutpt_bef+1,2]/100*D
        else:                
            continue
                
        #find intersection after
        #C = Point(Path[line_lac+1,1], Path[line_lac+1,0])
        cutpt_aft = 0
        check_int=False
        while not check_int and cutpt_aft*Csize<R*(coefplat+0.5):   
            cutpt_aft+=1
            vois = []
            for ide in range(line_lac,min(Path.shape[0],line_lac+cutpt_aft+1)):
                vois.append(Point(Path[ide,1], Path[ide,0]))
            RoadAft = LineString(vois)
            check_int = RingR15.intersects(RoadAft)
            
        if check_int:
            intaft = RingR15.intersection(RoadAft)
            x2 = Point(intaft.coords[0])
            x,y = Path[line_lac+cutpt_aft,1],Path[line_lac+cutpt_aft,0]
            D =  Distplan(y, x, x2.y, x2.x)
            x2z = Path[line_lac+cutpt_aft,9]-Path[line_lac+cutpt_aft,2]/100*D
        else:                
            continue
        
        #get turn direction
        azfrom = Path[line_lac,3]
        azto = Path[line_lac+1,3]
        dif =  diff_az(azfrom,azto)
        sign=1
        if abs((azto-dif)%360-azfrom)<0.1:
            sign*=-1
               
        #get point on radius                
        pol1 = calculate_polar(B.x,B.y,x1.x,x1.y)
        pol2 = calculate_polar(B.x,B.y,x2.x,x2.y)        
                  
        diff_angle = 360- diff_az(pol2,pol1)  
               
        nbpt = int(diff_angle/45.) 
        start = int(0.5*(360-(nbpt-1)*45- diff_az(pol2,pol1))+0.5)  
        pt_list = []
        pol = int((pol1+sign*start)%360+0.5)        
        xbef,ybef=x1.x,x1.y
        x,y=coords[pol,1]+B.x,coords[pol,2]+B.y
        D = []
        D.append( Distplan(y, x, ybef,xbef))       
        pt_list.append([x,y])
        ybef,xbef=y,x
        for i in range(1,nbpt):            
            pol = int((pol1+i*sign*45+sign*start)%360)
            x,y=coords[pol,1]+B.x,coords[pol,2]+B.y
            pt_list.append([x,y])
            D.append( Distplan(y, x, ybef,xbef))
            xbef,ybef=x,y
        D.append( Distplan(x2.y, x2.x, ybef,xbef))
        Dcum=np.sum(D)  
        sl = (x2z-x1z) /  Dcum   
        newPath = np.zeros((Path.shape[0]+len(pt_list)+3-cutpt_bef-cutpt_aft,Path.shape[1]))
        newPath[0:line_lac-cutpt_bef+1]= Path[0:line_lac-cutpt_bef+1]
        newPath[line_lac-cutpt_bef+1,0:2] = x1.y,x1.x            
        newPath[line_lac-cutpt_bef+1,7:9] = lac[0],0
        newPath[line_lac-cutpt_bef+1,9] = x1z 
        newPath[line_lac-cutpt_bef+1,2] = Path[line_lac-cutpt_bef+1,2]
        for i,pt in enumerate(pt_list):
            newPath[line_lac-cutpt_bef+2+i,0:2]=pt[1],pt[0]
            newPath[line_lac-cutpt_bef+2+i,7:9] = lac[0],1
            newPath[line_lac-cutpt_bef+2+i,2] = sl*100
            newPath[line_lac-cutpt_bef+2+i,9] = x1z+sl*np.sum(D[:i+1])
        newPath[line_lac-cutpt_bef+3+i,0:2]=x2.y,x2.x
        newPath[line_lac-cutpt_bef+3+i,9]=x2z
        newPath[line_lac-cutpt_bef+3+i,2]=sl*100
        newPath[line_lac-cutpt_bef+3+i,7:9] = lac[0],1
        newPath[line_lac-cutpt_bef+4+i:]=Path[line_lac+cutpt_aft:] 
    
        Path=np.copy(newPath)
        
    
    #Complete table
    #Y X SLOPE AZ DPLAN D3D Z LSL
    #0 1 2     3  4     5   6 7
    keep = np.ones((Path.shape[0],),dtype=np.uint8)
    for i in range(1,Path.shape[0]):
        y,x = Path[i,0:2]
        y1,x1 = Path[i-1,0:2]
        Path[i,4]=np.sqrt((x1-x)**2+(y1-y)**2)
        if Path[i,4]!=0:
            Path[i,3]=calculate_azimut(x1,y1,x,y)  
        else:
            keep[i]=0
    tp = keep==1
    Path = Path[tp] 
       
    return Path
  

def check_field(filename,fieldname):    

    """Checks if a specific field exists in the attribute table of a vector dataset.

    :param filename: Path to the vector dataset.
    :type filename: str
    :param fieldname: Name of the field to check.
    :type fieldname: str

    :return: 0 if the field does not exist, 1 if the field exists and has consistent values across all features, 
             2 if the field exists but has missing values in some features.
    :rtype: int

    :raises: None
    """
    test=0
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            test=1
            break
    if test:
        featureCount = layer.GetFeatureCount()
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))
        source_ds.Destroy() 
        if len(vals)!=featureCount:
            test=2
    
    return test


def raster_get_info(in_file_name):
    
    """Retrieves information about a raster dataset.

    :param in_file_name: Path to the input raster file.
    :type in_file_name: str

    :return: Names and corresponding values of important raster parameters,
             spatial reference of the raster dataset,
             and extent of the raster dataset.
    :rtype: tuple

    :raises: None
    """
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    
    return names,values,src_proj,Extent


#Chech all spatial entries before processing
def check_files(Dtm_file,Waypoints_file,Property_file):
    
    """Checks the validity of input spatial files.

    :param Dtm_file: Path to the Digital Terrain Model (DTM) raster file.
    :type Dtm_file: str

    :param Waypoints_file: Path to the waypoints spatial file.
    :type Waypoints_file: str
    
    :param Property_file: Path to the property spatial file.
    :type Property_file: str

    :return: Tuple containing:
             - Status of file checks (1 if all checks pass, 0 otherwise),
             - Message detailing any identified problems with the input files,
             - Cell size of the DTM raster file.
    :rtype: tuple

    :raises: None
    """
    test = 1
    Csize = None
    mess=QCoreApplication.translate("MainWindow","\nLES PROBLEMES SUIVANTS ONT ETE IDENTIFIES CONCERNANT LES ENTREES SPATIALES: \n")
    #Check DTM    
    try:
        _,values,_,_ = raster_get_info(Dtm_file)  
        Csize = values[4]
        if values[5]==None:           
            mess+=QCoreApplication.translate("MainWindow"," -   Raster MNT : Aucune valeur de NoData definie. Attention, cela peut engendrer des résultats éronnés.\n" )
    except:
        test=0
        mess+=QCoreApplication.translate("MainWindow"," -   Raster MNT :  Le chemin d'acces est manquant ou incorrect. Ce raster est obligatoire\n") 
            
    #Check Waypoints 
    try:    
        testfd = check_field(Waypoints_file,"ID_TRON")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Le champs 'ID_TRON' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Veuillez remplir le champs 'ID_TRON' pour toutes les entités\n")         
        
        testfd =  check_field(Waypoints_file,"ID_POINT")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Le champs 'ID_POINT' est manquant\n"  )
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Veuillez remplir le champs 'ID_POINT' pour toutes les entités\n" )       
        
        testfd = check_field(Waypoints_file,"BUFF_POINT")
        if testfd==0:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Le champs 'BUFF_POINT' est manquant\n" ) 
        elif testfd==2:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -  Couche points de passage : Veuillez remplir le champs 'BUFF_POINT' pour toutes les entités\n"   )         
    except:
        test=0
        mess+=QCoreApplication.translate("MainWindow"," -   Couche points de passage : Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire\n" )
    
    #Check foncier    
    if Property_file!="":   
        try:
            testfd = check_field(Property_file,"FONC_OK")
            if testfd==0:
                test=0
                mess+=QCoreApplication.translate("MainWindow"," -  Couche foncier : Le champs 'FONC_OK' est manquant\n"  )
            elif testfd==2:
                test=0
                mess+=QCoreApplication.translate("MainWindow"," -  Couche foncier : Veuillez remplir le champs 'FONC_OK' pour toutes les entités\n"    ) 
        except:
            test=0
            mess+=QCoreApplication.translate("MainWindow"," -   Couche foncier : Le chemin d'acces est incorrect. \n")
    if not test:
        mess+="\n"
        mess+=QCoreApplication.translate("MainWindow","MERCI DE CORRIGER AVANT DE RELANCER L'OUTIL\n")
    
    return test,mess,Csize


def load_float_raster(raster_file):

    """Loads a floating-point raster dataset.

    :param raster_file: Path to the raster file.
    :type raster_file: str

    :return: Tuple containing:
             - Array: 2D NumPy array representing the raster values,
             - Extent: Extent of the raster dataset [xmin, xmax, ymin, ymax],
             - Csize: Cell size of the raster dataset,
             - proj: Projection information of the raster dataset.
    :rtype: tuple

    :raises: None
    """
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()      
    Array = dataset_val.ReadAsArray()
    if nodatavalue is not None:
        Array[Array==nodatavalue]=-9999
    Array[np.isnan(Array)]=-9999
    dataset.FlushCache()
    
    return np.float_(Array),Extent,Csize,proj


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    """
    Convert shapefile to numpy array
    ----------
    Parameters
    ----------
    file_name:              string      Complete name of the shapefile to convert
    Extent:                 list        Extent of the array : [xmin,xmax,ymin,ymax]
    Csize:                  int, float  Cell resolution of the output array
    attribute_name:         string      Attribute name of the field used for rasterize
    order_field (optional): string      Attribute name of the field used to order the rasterization
    order (optional):       string      Sorting type : 'ASC' for ascending or 'DESC' descending

    Returns
    -------
    mask_array :            ndarray int32
    ----------
    Examples
    --------
    >>> import ogr,gdal
    >>> import numpy as np
    >>> mask_array = shapefile_to_np_array("Route.shp",[0,1000,0,2000],5,"Importance","Importance",'ASC')
    """
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        
        return mask_arr
  

def prepa_obstacle(Obstacles_directory,Extent,Csize,ncols,nrow):
    
    """Prepares obstacle raster data.

    :param Obstacles_directory: Directory containing obstacle shapefiles.
    :type Obstacles_directory: str
    :param Extent: Extent of the raster dataset [xmin, xmax, ymin, ymax].
    :type Extent: list
    :param Csize: Cell size of the raster dataset.
    :type Csize: float
    :param ncols: Number of columns in the raster dataset.
    :type ncols: int
    :param nrows: Number of rows in the raster dataset.
    :type nrows: int

    :return: Raster representing the location of obstacles (0 where there are no obstacles).
    :rtype: numpy.ndarray

    :raises: None
    """
    liste_file = os.listdir(Obstacles_directory)
    liste_obs = []
    for files in liste_file:
        if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
    if len(liste_obs)>0:
        Obstacles_skidder = shapefile_obs_to_np_array(liste_obs,Extent,Csize)        
    else: Obstacles_skidder = np.zeros((nrow,ncols),dtype=np.int8)
    
    return Obstacles_skidder


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    """
    Create a numpy array from shapefile contained in a directory
    ----------
    Parameters
    ----------
    file_list:              string      List of .shp file to rasterize
    Extent:                 list        Extent of the area : [xmin,xmax,ymin,ymax]
    Csize:                  int, float  Cell resolution of the area  

    Returns
    -------
    mask_array :            ndarray int32
    """
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=int)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle = Obstacle + mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    
    return Obstacle


def get_proj_from_road_network(road_network_file):
    
    """Extracts the projection information from a road network file.

    This function opens the provided road network file and retrieves the spatial reference
    information from its layer. It then returns the Well-Known Text (WKT) representation 
    of the spatial reference and the SpatialReference object.

    :param road_network_file: Path to the road network file.
    :type road_network_file: str

    :return: A tuple containing the Well-Known Text (WKT) representation of the spatial reference
             and the SpatialReference object.
    :rtype: tuple

    :raises: None
    """
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    
    return source_srs.ExportToWkt(),source_srs

 
def Path_to_lineshape(Path,Line_Shape_Path,projection,Extent,Csize,dtm,nb_lac):
    """
    Convert a file of point coordinate to a line shapefile
    ----------
    Parametres
    ----------
    point_coords:     ndarray float    Matrix contenaing positiosn X Y and line ID
    Line_Shape_Path:  string           Complete name of the output shapefile containing lines
    projection:       string           Spatial projection 

    Examples
    --------
    >>> import ogr,gdal
    >>> points_to_lineshape(point_coords,"Line.shp",projection)
    """
    x0,y0=get_xy0(Extent,Csize)
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()   
    new_field = ogr.FieldDefn('ID_SEG', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_CUM', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_CUM', ogr.OFTReal)
    layer.CreateField(new_field)   
    new_field = ogr.FieldDefn('PENTE_LONG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_DEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_GRAD', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('DELTA_Z', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PTSUPMAX', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AMONT', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AVAL', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('P_ROCHER', ogr.OFTInteger)
    layer.CreateField(new_field)
    if nb_lac==0:
        new_field = ogr.FieldDefn('METHOD', ogr.OFTInteger)
        layer.CreateField(new_field)
    nbpts = Path.shape[0]
    ind=0
    point_coords = np.int32(Path[:,0:2])
    prev_L,L3Dcum = 0,0
    while ind<nbpts-1: 
        line = ogr.Geometry(ogr.wkbLineString)
        yS,xS = point_coords[ind]
        yE,xE = point_coords[ind+1]
        yrS,xrS = y0-yS*Csize,xS*Csize+x0
        yrE,xrE = y0-yE*Csize,xE*Csize+x0
        line.AddPoint(xrS,yrS)
        line.AddPoint(xrE,yrE)
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('ID_SEG',ind+1)
        feature.SetField('X_DEB',xrS)
        feature.SetField('Y_DEB',yrS)
        feature.SetField('Z_DEB',dtm[yS,xS])
        feature.SetField('X_FIN',xrE)
        feature.SetField('Y_FIN',yrE)
        feature.SetField('Z_FIN',dtm[yE,xE])
        Lcum = Path[ind+1,4]
        D = Lcum-prev_L       
        feature.SetField('LPLAN_SEG',D)
        feature.SetField('LPLAN_CUM',Lcum)
        prev_L = Lcum
        dZ = dtm[yE,xE]-dtm[yS,xS]
        L3D = np.sqrt(dZ**2+D**2)
        L3Dcum+=L3D
        feature.SetField('L3D_SEG',L3D)
        feature.SetField('L3D_CUM',L3Dcum)
        feature.SetField('PENTE_LONG',Path[ind+1,2])
        feature.SetField('L_PTSUPMAX',Path[ind+1,6])
        feature.SetField('AZI_DEG',Path[ind+1,3])
        feature.SetField('AZI_GRAD',round(Path[ind+1,3]*20/18.,1))
        feature.SetField('DELTA_Z',dZ) 
        if nb_lac==0:
            feature.SetField('METHOD',0) 
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
        ind +=1        
    
    target_ds.Destroy() 
    
    
def NewPath_to_lineshape(Path,Line_Shape_Path,projection):
    """
    Convert a file of point coordinate to a line shapefile
    ----------
    Parametres
    ----------
    point_coords:     ndarray float    Matrix contenaing positiosn X Y and line ID
    Line_Shape_Path:  string           Complete name of the output shapefile containing lines
    projection:       string           Spatial projection 

    Examples
    --------
    >>> import ogr,gdal
    >>> points_to_lineshape(point_coords,"Line.shp",projection)
    """   
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()   
    new_field = ogr.FieldDefn('ID_SEG', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_DEB', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('X_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Y_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Z_FIN', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('LPLAN_CUM', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_SEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L3D_CUM', ogr.OFTReal)
    layer.CreateField(new_field)   
    new_field = ogr.FieldDefn('PENTE_LONG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_DEG', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AZI_GRAD', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('DELTA_Z', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PTSUPMAX', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('METHOD', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('L_PLAT', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AMONT', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('PT_AVAL', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('P_ROCHER', ogr.OFTInteger)
    layer.CreateField(new_field)    
    nbpts = Path.shape[0]
    ind=0
    point_coords = Path[:,0:2]
    Lcum,L3Dcum=0,0
    while ind<nbpts-1: 
        line = ogr.Geometry(ogr.wkbLineString)
        yrS,xrS = point_coords[ind]
        yrE,xrE = point_coords[ind+1]
        line.AddPoint(float(xrS),float(yrS))
        line.AddPoint(float(xrE),float(yrE))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('METHOD',Path[ind+1,8])
        feature.SetField('ID_SEG',ind+1)
        feature.SetField('X_DEB',float(xrS))
        feature.SetField('Y_DEB',float(yrS))
        feature.SetField('Z_DEB',float(Path[ind,9]))
        feature.SetField('X_FIN',float(xrE))
        feature.SetField('Y_FIN',float(yrE))
        feature.SetField('Z_FIN',float(Path[ind+1,9]))
        dZ = Path[ind+1,9]-Path[ind,9]
        L3D = np.sqrt(dZ**2+Path[ind+1,4]**2)
        L3Dcum+=L3D   
        Lcum += Path[ind+1,4]
        feature.SetField('LPLAN_SEG',float(Path[ind+1,4]))
        feature.SetField('LPLAN_CUM',float(Lcum))
        feature.SetField('L3D_SEG',float(L3D))
        feature.SetField('L3D_CUM',float(L3Dcum))
        feature.SetField('PENTE_LONG',float(Path[ind+1,2]))
        feature.SetField('L_PTSUPMAX',float(Path[ind+1,6]))
        feature.SetField('AZI_DEG',float(Path[ind+1,3]))
        feature.SetField('AZI_GRAD',float(round(Path[ind+1,3]*20/18.,1)))
        feature.SetField('DELTA_Z',float(dZ))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
        ind +=1        
    
    target_ds.Destroy()  

   
def reconstruct_path(goal, start, Best,Tab_corresp):    
    
    """Reconstructs the path from the goal node to the start node.

    This function takes the goal node, start node, a matrix containing information
    about the best path, and a matrix containing correspondence between nodes 
    and coordinates, and reconstructs the path from the goal node to the start node.

    :param goal: The goal node representing the end of the path.
    :type goal: int

    :param start: The start node representing the beginning of the path.
    :type start: int

    :param Best: A matrix containing information about the best path.
    :type Best: numpy.ndarray
    :param Tab_corresp: A matrix containing correspondence between nodes and coordinates.
    :type Tab_corresp: numpy.ndarray

    :return: An array representing the reconstructed path, including coordinates,
             azimuth, slope, distance, and additional information.
    :rtype: numpy.ndarray

    :raises: None
    """
    current = goal
    path = []
    while current != start:
        path.append([Tab_corresp[current,0],Tab_corresp[current,1],Best[current,3],
                     Best[current,4],Best[current,2],Best[current,1],Best[current,7]])
        current = int(Best[current,5])
    path.append([Tab_corresp[current,0],Tab_corresp[current,1],-1,-1,0,0,0]) # optional
    path.reverse() # optional
    
    return np.array(path)


def calculate_azimut(x1,y1,x2,y2):
   
    """Calculates the azimuth between two points from their coordinates.

    This function calculates the azimuth (bearing) between two points represented
    by their coordinates (x1, y1) and (x2, y2).

    :param x1: The x-coordinate of the first point.
    :type x1: float

    :param y1: The y-coordinate of the first point.
    :type y1: float
    :param x2: The x-coordinate of the second point.
    
    :type x2: float
    :param y2: The y-coordinate of the second point.
    :type y2: float

    :return: The azimuth between the two points in degrees, ranging from 0 to 360.
    :rtype: float

    :raises: None
    """
    DX = x2-x1
    DY = y2-y1
    Deuc = np.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = np.degrees(np.arccos(DY/Deuc))
    Angle *=Fact
    
    return Angle%360


def get_xy0(Extent,Csize):   
    
    """Calculate the coordinates of the origin point based on the provided extent and pixel size.

    This function calculates the coordinates of the origin point (x0, y0) based on the provided
    extent and pixel size. The origin point is the center of the first pixel in the raster grid.

    :param Extent: The extent of the raster dataset in the form [xmin, xmax, ymin, ymax].
    :type Extent: list
    :param Csize: The size of each pixel in meters.
    :type Csize: float

    :return: The coordinates of the origin point (x0, y0).
    :rtype: tuple

    :raises: None
    """
    
    return Extent[0]+0.5*Csize,Extent[3]-0.5*Csize


def get_Slope(Dtm_file):
    
    """Calculate the slope from a digital terrain model (DTM) raster file.

    This function reads the provided DTM raster file and calculates the slope using GDAL's
    DEMProcessing utility. The slope is computed in percent format.

    :param Dtm_file: The file path to the digital terrain model (DTM) raster file.
    :type Dtm_file: str

    :return: The slope raster array representing the slope of the terrain in percent format.
    :rtype: numpy.ndarray

    :raises: None
    """
    a=gdal.DEMProcessing('slope', Dtm_file, 'slope',slopeFormat="percent",computeEdges=True,format='MEM')
    
    return a.GetRasterBand(1).ReadAsArray()


def create_res_dir(Result_Dir,trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,penalty_z,D_neighborhood):
    
    
    """Create a directory for storing simulation results based on specified parameters.

    This function creates a directory within the specified Result_Dir to store simulation results.
    The directory name is generated based on the provided parameters, including:

    - trans_slope_all: Transition slope for all road sections.
    - trans_slope_hairpin: Transition slope specifically for hairpin turns.
    - min_slope: Minimum allowable slope for road segments.
    - max_slope: Maximum allowable slope for road segments.
    - penalty_xy: Penalty factor for changes in x-y direction.
    - penalty_z: Penalty factor for changes in z (elevation) direction.
    - D_neighborhood: Neighborhood distance for considering adjacent pixels in computations.

    The directory name format is as follows:
    Simu_<optnum>_Pl(<min_slope>-<max_slope>)_Pt(<trans_slope_all>-<trans_slope_hairpin>)_Pen(<penalty_xy>-<penalty_z>)_D(<D_neighborhood>)

    :param Result_Dir: The path to the directory where simulation results will be stored.
    :type Result_Dir: str

    :param trans_slope_all: Transition slope for all road sections.
    :type trans_slope_all: float

    :param trans_slope_hairpin: Transition slope specifically for hairpin turns.
    :type trans_slope_hairpin: float

    :param min_slope: Minimum allowable slope for road segments.
    :type min_slope: float

    :param max_slope: Maximum allowable slope for road segments.
    :type max_slope: float

    :param penalty_xy: Penalty factor for changes in x-y direction.
    :type penalty_xy: float

    :param penalty_z: Penalty factor for changes in z (elevation) direction.
    :type penalty_z: float

    :param D_neighborhood: Neighborhood distance for considering adjacent pixels in computations.
    :type D_neighborhood: float


    :return: The path to the created directory for storing simulation results.
    :rtype: str

    :raises: None
    """
    dirs = [d for d in os.listdir(Result_Dir) if os.path.isdir(os.path.join(Result_Dir, d))]
    list_dir = []
    for dire in dirs:
        if dire[:5]=='Simu_':
            list_dir.append(dire)
    optnum = len(list_dir)+1
    Rspace=Result_Dir+'Simu_'+str(optnum)    
    Rspace+="_Pl("+str(min_slope)+"-"+str(max_slope)+")"
    Rspace+="_Pt("+str(trans_slope_all)+"-"+str(trans_slope_hairpin)+")"
    Rspace+="_Pen("+str(penalty_xy)+"-"+str(penalty_z)+")"
    Rspace+="_D("+str(D_neighborhood)+")"
    try:os.mkdir(Rspace)
    except:pass   
    
    return Rspace+'/'


def heures(Hdebut):
    
    """Calculate the duration between a given start time and the current time.

    This function takes a start time (Hdebut) as input and calculates the duration
    between that start time and the current time (Hfin). It then formats this duration
    along with the start and end times into strings.

    :param Hdebut: The start time.
    :type Hdebut: datetime.datetime

    :return: A tuple containing:
             - The formatted duration string (e.g., '3h 15m 20s').
             - The formatted current time string.
             - The formatted start time string.
    :rtype: tuple

    :raises: None
    """
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    str_duree = str(duree).split('.')[0]
    str_duree = str_duree.split(':')[0] + 'h ' + str_duree.split(':')[1] + 'm ' + str_duree.split(':')[2] + 's'
    str_debut = Hdebut.strftime('%d/%m/%Y %H:%M:%S')
    str_fin = Hfin.strftime('%d/%m/%Y %H:%M:%S')
    
    return str_duree, str_fin, str_debut


def get_param(trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,
              penalty_z,D_neighborhood,max_diff_z,angle_hairpin,Dtm_file,Obs_Dir,
              Waypoints_file,Property_file,Csize,Lmax_ab_sl,Radius):
    
    
    """Generate a text summary of the parameters used for modeling.

    This function constructs a text summary containing the filenames of the files
    used for modeling (MNT, Points de passage, Foncier, and Dossier Obstacles) and
    the parameters used for the modeling process.

    :param trans_slope_all: Maximum slope in traverse direction at any point.
    :type trans_slope_all: float

    :param trans_slope_hairpin: Maximum slope in traverse direction for placing a hairpin turn.
    :type trans_slope_hairpin: float

    :param min_slope: Minimum slope in longitudinal direction.
    :type min_slope: float

    :param max_slope: Maximum slope in longitudinal direction.
    :type max_slope: float

    :param penalty_xy: Penalty for changing direction.
    :type penalty_xy: float

    :param penalty_z: Penalty for changing the slope direction.
    :type penalty_z: float

    :param D_neighborhood: Radius of search around a pixel.
    :type D_neighborhood: float

    :param max_diff_z: Maximum difference between terrain altitude and theoretical altitude of the trace.
    :type max_diff_z: float

    :param angle_hairpin: Angle beyond which a turn is considered a hairpin.
    :type angle_hairpin: float

    :param Dtm_file: Path to the Digital Terrain Model (MNT) file.
    :type Dtm_file: str

    :param Obs_Dir: Directory containing obstacle files.
    :type Obs_Dir: str

    :param Waypoints_file: Path to the waypoints file.
    :type Waypoints_file: str

    :param Property_file: Path to the property file.
    :type Property_file: str

    :param Csize: Resolution of the MNT file (cell size).
    :type Csize: float

    :param Lmax_ab_sl: Maximum cumulative length with cross slope > maximum cross slope.
    :type Lmax_ab_sl: float

    :param Radius: Turning radius applied to hairpin turns.
    :type Radius: float

    :return: Text summary of the parameters used for modeling.
    :rtype: str
    """
    txt = QCoreApplication.translate("MainWindow","FICHIERS UTILISES POUR LA MODELISATION:") + "\n\n"
    txt += QCoreApplication.translate("MainWindow","   - MNT :                   ") + Dtm_file+"\n"
    txt += QCoreApplication.translate("MainWindow","     Résolution (m) :        ")+str(Csize)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Points de passage :     ") + Waypoints_file+"\n"
    txt += QCoreApplication.translate("MainWindow","   - Foncier :               ") + Property_file+"\n"
    txt += QCoreApplication.translate("MainWindow","   - Dossier Obstacles :     ") + Obs_Dir+"\n\n\n"
    txt += "" .join (["_"]*80) + "\n\n"
    txt += QCoreApplication.translate("MainWindow", "PARAMETRES UTILISES POUR LA MODELISATION:")+ "\n\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en long min. :")+"                                                        "+str(min_slope)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en long max. :")+"                                                        "+str(max_slope)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en travers max. en tout point :")+"                                       "+str(trans_slope_all)+" %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pente en travers max. pour implanter un virage en lacet :")+"                   "+str(trans_slope_hairpin)+"  %\n"
    txt += QCoreApplication.translate("MainWindow","   - Pénalité de changement de direction :")+"                                       "+str(penalty_xy)+" m/"+str(angle_hairpin)+"°\n"
    txt += QCoreApplication.translate("MainWindow","   - Pénalité de changement du sens de pente en long :")+"                           "+str(penalty_z)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Rayon de recherche autour d'un pixel :")+"                                      "+str(D_neighborhood)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Différence max. entre altitude du terrain et altitude théorique du trace :")+"  "+str(max_diff_z)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Angle au-delà duquel un virage est considéré comme lacet :")+"                  "+str(angle_hairpin)+" °\n"
    txt += QCoreApplication.translate("MainWindow","   - Rayon de braquage appliqué aux lacets :")+"                                     "+str(Radius)+" m\n"
    txt += QCoreApplication.translate("MainWindow","   - Longueur cumulée max. avec Pente en travers > Pente en travers max. :")+"       "+str(Lmax_ab_sl)+" m\n"
    
    return txt


def create_param_file(Rspace,param,res_process,str_duree,str_fin,str_debut):
    
    """Create a parameter file summarizing simulation results and processing details.

    This function generates a text file containing details about the simulation parameters,
    processing results, and execution duration.

    :param Rspace: Directory where the parameter file will be saved.
    :type Rspace: str

    :param param: Text summary of the parameters used for modeling.
    :type param: str

    :param res_process: Text summary of the processing results.
    :type res_process: str

    :param str_duree: Duration of script execution.
    :type str_duree: str

    :param str_fin: Date and time at the end of script execution.
    :type str_fin: str

    :param str_debut: Date and time at the start of script execution.
    :type str_debut: str

    :raises: None

    :rtype: None
    """
    filename = Rspace +"Parametre_simulation.txt"    
    txt = QCoreApplication.translate("MainWindow","SylvaRoaD")+"\n\n"
    ver =  "0.2"
    date = "03/2024"
    txt += QCoreApplication.translate("MainWindow","Version du programme:" + ver + date)+"\n"
    txt += QCoreApplication.translate("MainWindow","Auteur: Zenner Yoann - Cosylval")+"\n\n"
    txt += QCoreApplication.translate("MainWindow","Date et heure de lancement du script:")+"                                      "+str_debut+"\n"
    txt += QCoreApplication.translate("MainWindow","Date et heure a la fin de l'éxécution du script:")+"                           "+str_fin+"\n"
    txt += QCoreApplication.translate("MainWindow","Temps total d'éxécution du script:")+"                                         "+str_duree+"\n\n"
    txt += "" .join (["_"]*80) + "\n\n"
    txt += param
    txt += "" .join (["_"]*80) + "\n\n"
    txt += res_process    
    fichier = open(filename, "w")
    fichier.write(txt)
    fichier.close()
    


def get_points_from_waypoints(Waypoints_file,Dtm_file):
    
    """Retrieve points from a waypoints file and convert them to pixel coordinates.

    This function reads a waypoints file containing point features with associated attributes
    and converts the coordinates of each point to pixel coordinates based on the provided
    digital terrain model (DTM) file. The waypoints file should contain fields for 'ID_TRON',
    'ID_POINT', 'BUFF_POINT' to identify each point.

    :param Waypoints_file: Path to the waypoints file.
    :type Waypoints_file: str

    :param Dtm_file: Path to the digital terrain model (DTM) file.
    :type Dtm_file: str

    :raises: None

    :return: Array containing points with pixel coordinates sorted by y-coordinate and then by x-coordinate.
    :rtype: numpy.ndarray
    """
    #Open Dtm_file
    src_ds=gdal.Open(Dtm_file) 
    gt=src_ds.GetGeoTransform()
    
    # Get waypoint
    source_ds = ogr.Open(Waypoints_file)
    source_layer = source_ds.GetLayer()
    geoLocations = []    
    for feat in source_layer:
        geom = feat.GetGeometryRef() 
        idtron = feat.GetField("ID_TRON")
        idpt = feat.GetField("ID_POINT")
        buff = feat.GetField("BUFF_POINT") 
        seg = []  
        mx,my,_ = geom.GetPoint(0)
        #Convert from map to pixel coordinates.
        #Only works for geotransforms with no rotation.
        px = int((mx - gt[0]) / gt[1]) #x pixel
        py = int((my - gt[3]) / gt[5]) #y pixel       
        seg.append(idtron)
        seg.append(idpt)
        seg.append(buff)
        seg.append(py)
        seg.append(px)        
        geoLocations.append(seg)
    
    pt_list = np.int16(geoLocations)
    ind = np.lexsort((pt_list[:,1], pt_list[:,0]))   
     
    return pt_list[ind]

    

def get_waypoints(id_tron,pt_list): 
    
    """Retrieve waypoints corresponding to a specific road segment.

    This function takes a road segment ID and a list of points, and returns a list of
    waypoints representing the segment. Waypoints are defined by their starting and ending
    coordinates and the associated buffer size.

    :param id_tron: ID of the road segment.
    :type id_tron: int

    :param pt_list: Array containing points with attributes.
    :type pt_list: numpy.ndarray

    :raises: None

    :return: List of waypoints defining the road segment, each containing the starting and
             ending coordinates and the associated buffer size.
    :rtype: list
    """
    seg_list = []
    ptlist2 = pt_list[pt_list[:,0]==id_tron]
    nbpt = ptlist2.shape[0]
             
    for i in range(nbpt-1):
        start = ptlist2[i,3],ptlist2[i,4]   
        end = ptlist2[i+1,3],ptlist2[i+1,4]   
        seg_list.append([start,end,ptlist2[i+1,2]])
    return seg_list
    


def save_param_file(Wspace,Dtm_file,Obs_Dir,Waypoints_file,Property_file,Result_Dir,
                    trans_slope_all,trans_slope_hairpin,min_slope,max_slope,penalty_xy,
                    penalty_z,D_neighborhood,max_diff_z,angle_hairpin,Lmax_ab_sl,Rspace,Radius):
    
    """Save simulation parameters to a NumPy file.

    :param workspace: Workspace directory.
    :type workspace: str

    :param dtm_file: Path to the digital terrain model (DTM) file.
    :type dtm_file: str

    :param obs_dir: Directory containing obstacle files.
    :type obs_dir: str

    :param waypoints_file: Path to the waypoints file.
    :type waypoints_file: str

    :param property_file: Path to the property file.
    :type property_file: str

    :param result_dir: Directory to save simulation results.
    :type result_dir: str

    :param trans_slope_all: Maximum slope allowed in traverse direction.
    :type trans_slope_all: float

    :param trans_slope_hairpin: Maximum slope allowed for hairpin turns.
    :type trans_slope_hairpin: float

    :param min_slope: Minimum slope allowed.
    :type min_slope: float

    :param max_slope: Maximum slope allowed.
    :type max_slope: float

    :param penalty_xy: Penalty for changing direction.
    :type penalty_xy: float

    :param penalty_z: Penalty for changing longitudinal slope.
    :type penalty_z: float

    :param d_neighborhood: Distance around a pixel to consider for analysis.
    :type d_neighborhood: float

    :param max_diff_z: Maximum allowable difference between terrain altitude and
                       theoretical track altitude.
    :type max_diff_z: float

    :param angle_hairpin: Angle beyond which a turn is considered a hairpin turn.
    :type angle_hairpin: float

    :param lmax_ab_sl: Maximum cumulative length with traverse slope greater than
                       maximum traverse slope.
    :type lmax_ab_sl: float

    :param rspace: Path to save the simulation parameters.
    :type rspace: str

    :param radius: Turning radius applied to hairpin turns.
    :type radius: float

    :raises: None

    :rtype: None
    """
    parameters = {
        'Workspace': Wspace,
        'DTM_File': Dtm_file,
        'Obs_Dir': Obs_Dir,
        'Waypoints_File': Waypoints_file,
        'Property_File': Property_file,
        'Result_Dir': Result_Dir,
        'Trans_Slope_All': trans_slope_all,
        'Trans_Slope_Hairpin': trans_slope_hairpin,
        'Min_Slope': min_slope,
        'Max_Slope': max_slope,
        'Penalty_XY': penalty_xy,
        'Penalty_Z': penalty_z,
        'D_Neighborhood': D_neighborhood,
        'Max_Diff_Z': max_diff_z,
        'Angle_Hairpin': angle_hairpin,
        'Lmax_Ab_Sl': Lmax_ab_sl,
        'Rspace': Rspace,
        'Radius': Radius
    }

    np.save(Rspace + "SylvaRoaD_param.npy", parameters)
    


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    """
    Create Tiff raster from numpy array   
    ----------
    Parameters
    ----------
    Array:             np.array    Array name
    file_name:         string      Complete name of the output raster
    Extent:            list        Extent of the area : [xmin,xmax,ymin,ymax]
    nrows:             int         Number of rows in the array
    ncols:             int         Number of columns in the array
    Csize:             int, float  Cell resolution of the array  
    road_network_proj: string      Spatial projection
    nodata_value:      int, float  Value representing nodata in the array
    raster_type:       string      'INT32' (default),'UINT8','UINT16','FLOAT32','FLOAT16'

    """
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()
    






